{
  "name": "Gocelery",
  "tagline": "Celery Distributed Task Queue in Go",
  "body": "# gocelery\r\n\r\nGo Client/Server for Celery Distributed Task Queue\r\n\r\n[![Build Status](https://travis-ci.org/shicky/gocelery.svg?branch=master)](https://travis-ci.org/shicky/gocelery)\r\n[![Coverage Status](https://coveralls.io/repos/github/shicky/gocelery/badge.svg?branch=master)](https://coveralls.io/github/shicky/gocelery?branch=master)\r\n[![Go Report Card](https://goreportcard.com/badge/github.com/shicky/gocelery)](https://goreportcard.com/report/github.com/shicky/gocelery)\r\n[![GoDoc](https://godoc.org/github.com/shicky/gocelery?status.svg)](https://godoc.org/github.com/shicky/gocelery)\r\n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/shicky/gocelery/blob/master/LICENSE)\r\n[![motivation](https://img.shields.io/badge/made%20with-%E2%99%A1-ff69b4.svg)](https://github.com/shicky/gocelery)\r\n\r\n## Why?\r\n\r\nHaving being involved in a number of projects migrating server from python to go, I have realized Go can help improve performance of existing python web applications.\r\nCelery distributed tasks are used heavily in many python web applications and this library allows you to implement celery workers in Go as well as being able to submit celery tasks in Go.\r\n\r\nYou can also use this library as pure go distributed task queue.\r\n\r\n## Go Celery Worker in Action\r\n\r\n![demo](https://raw.githubusercontent.com/shicky/gocelery/master/demo.gif)\r\n\r\n## Supported Brokers/Backends\r\n\r\n* Redis (broker/backend)\r\n\r\n\r\n## Celery Configuration\r\n\r\nCelery must be configured to use **json** instead of default **pickle** encoding.\r\nThis is because Go currently has no stable support for decoding pickle objects.\r\nPass below configuration parameters to use **json**.\r\n\r\n```python\r\nCELERY_TASK_SERIALIZER='json',\r\nCELERY_ACCEPT_CONTENT=['json'],  # Ignore other content\r\nCELERY_RESULT_SERIALIZER='json',\r\nCELERY_ENABLE_UTC=True,\r\n```\r\n\r\n## Celery Worker Example\r\n\r\nRun Celery Worker implemented in Go\r\n\r\n```go\r\n// example/worker/main.go\r\n\r\n// Celery Task\r\nfunc add(a int, b int) int {\r\n\treturn a + b\r\n}\r\n\r\nfunc main() {\r\n    // create broker\r\n\tceleryBroker := gocelery.NewCeleryRedisBroker(\"localhost:6379\", \"\")\r\n\t// create backend\r\n\tceleryBackend := gocelery.NewCeleryRedisBackend(\"localhost:6379\", \"\")\r\n\t// Configure with 2 celery workers\r\n\tceleryClient, _ := gocelery.NewCeleryClient(celeryBroker, celeryBackend, 2)\r\n\t// worker.add name reflects \"add\" task method found in \"worker.py\"\r\n\tceleryClient.Register(\"worker.add\", add)\r\n\t// Start Worker - blocking method\r\n\tgo celeryClient.StartWorker()\r\n\t// Wait 30 seconds and stop all workers\r\n\ttime.Sleep(30 * time.Second)\r\n\tceleryClient.StopWorker()\r\n}\r\n```\r\n```bash\r\ngo run example/worker/main.go\r\n```\r\n\r\n\r\nSubmit Task from Python Client\r\n```python\r\n# example/test.py\r\n\r\nfrom celery import Celery\r\n\r\napp = Celery('tasks',\r\n    broker='redis://localhost:6379',\r\n    backend='redis://localhost:6379'\r\n)\r\n\r\n@app.task\r\ndef add(x, y):\r\n    return x + y\r\n\r\nif __name__ == '__main__':\r\n    # submit celery task to be executed in Go workers\r\n    ar = add.apply_async((5456, 2878), serializer='json')\r\n    print(ar.get())\r\n```\r\n\r\n```bash\r\npython example/test.py\r\n```\r\n\r\n## Celery Client Example\r\n\r\nRun Celery Worker implemented in Python\r\n\r\n```python\r\n# example/worker.py\r\n\r\nfrom celery import Celery\r\n\r\napp = Celery('tasks',\r\n    broker='redis://localhost:6379',\r\n    backend='redis://localhost:6379'\r\n)\r\n\r\n@app.task\r\ndef add(x, y):\r\n    return x + y\r\n```\r\n\r\n```bash\r\ncd example\r\ncelery -A worker worker --loglevel=debug --without-heartbeat --without-mingle\r\n```\r\n\r\nSubmit Task from Go Client\r\n\r\n```go\r\nfunc main() {\r\n    // create broker\r\n\tceleryBroker := gocelery.NewCeleryRedisBroker(\"localhost:6379\", \"\")\r\n\t// create backend\r\n\tceleryBackend := gocelery.NewCeleryRedisBackend(\"localhost:6379\", \"\")\r\n\t// create client\r\n\tceleryClient, _ := gocelery.NewCeleryClient(celeryBroker, celeryBackend, 0)\r\n\t// send task\r\n\tasyncResult, err := celeryClient.Delay(\"worker.add\", 3, 5)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n    // check if result is ready\r\n\tisReady, _ := asyncResult.Ready()\r\n\tfmt.Printf(\"ready status %v\\n\", isReady)\r\n\r\n    // get result with 5s timeout\r\n\tres, err = asyncResult.Get(5 * time.Second)\r\n\tif err != nil {\r\n\t\tfmt.Println(err)\r\n\t} else {\r\n        fmt.Println(res)\r\n    }\r\n}\r\n```\r\n\r\n```bash\r\ngo run example/client/main.go\r\n```\r\n\r\n## Test\r\n\r\nMonitor Redis Message\r\n```bash\r\nredis-cli monitor\r\n```\r\n\r\n## Sample Celery Task Message\r\n\r\n```javascript\r\n{\r\n    \"expires\": null,\r\n    \"utc\": true,\r\n    \"args\": [5456, 2878],\r\n    \"chord\": null,\r\n    \"callbacks\": null,\r\n    \"errbacks\": null,\r\n    \"taskset\": null,\r\n    \"id\": \"c8535050-68f1-4e18-9f32-f52f1aab6d9b\",\r\n    \"retries\": 0,\r\n    \"task\": \"worker.add\",\r\n    \"timelimit\": [null, null],\r\n    \"eta\": null,\r\n    \"kwargs\": {}\r\n}\r\n```\r\n\r\n## Contributing\r\n\r\nYou are more than welcome to make any contributions.\r\nPlease create Pull Request for any changes.\r\n\r\nI need help on following items:\r\n* Supporting other brokers/backends such as RabbitMQ\r\n* Implementing more comprehensive tests\r\n\r\n## LICENSE\r\n\r\nThe gocelery is offered under MIT license.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}